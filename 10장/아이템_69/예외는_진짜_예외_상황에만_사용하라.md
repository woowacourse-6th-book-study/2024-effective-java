# 아이템69: 예외는 진짜 예외 상황에만 사용하라

## 핵심정리
- 예외는 예외 상황에서 쓸 의도로 설계되었다
- 흐름 제어를 위해 사용하지 마라
- 상태 의존적 메서드에는 상태 검사 메서드를 만들라
- 멀티 스레드나 코드 중복이 우려된다면 옵셔널/특정값 반환을 고려하자

---

### 예외는 예외 상황에 쓸 용도로 설계되었다

> 잘못된 예시 : 예외를 활용한 흐름 제어
```java
try{
    int i = 0;
    while(true)
        range[i++].climb();
} catch(ArrayIndexOutOfBoundsException e){}
        
```

- 잘못된 추론
```
  - fact) JVM은 배열에 접근 시, 경계를 검사한다
  - fact) 일반적인 반복문도 배열 경계 검사 (for)
  - expect) 검사를 반복문에 명시하면 같은 일이 중복되므로 하나를 생략한다
  ```

`이 추론은 잘못되었다`
- 예외는 예외상황에 쓸 용도로 만들어졌다
- 코드를 try-catch 에 넣으면 JVM이 적용가능한 최적화가 제한된다
- 사실 JVM이 알아서 중복검사를 수행하지 않는다


`제대로 동작하지 않을 수 있다`
- range[i++] 과 관련없이 climb 내부에서 ArrayIndexOutOfBoundsException 발생하면? > 복구된다

소결 : 예외를 사용한 반복문의 해악은 코드를 헷갈리게 하고 성능을 떨어뜨린다

---
## 예외를 흐름 제어의 목적으로 사용하지 말자

- Api 설계에서도 클라이언트가 정상적인 제어흐름에서 예외를 사용할 일이 없게 해야한다

### ex) 안 좋은 컬렉션 순회의 예시
```java
try{
    Iterator<Foo> i = collection.iterator();
    while(true){
        Foo foo = i.next();
        ...
    }
} catch(NoSuchElementException e) {}
```
- 반복자의 순회는 다음 원소가 있을 때 가능하다
- 다음 원소가 없음에도 접근하려 할 때 NoSuchElementException이 터진다
- 클라이언트의 목적은 컬렉션 순회이다.
- 컬렉션 순회과정에서 존재하지 않는 다음 원소에 접근하는 행위는 예외이다.
- 그러나, 컬렉션 순회를 목적으로 끝 이후 원소에 접근해, 예외를 터트려 잡는 행위는 흐름제어이다.
- 컬렉션 순회가 상태의존적 메서드이기 때문에 예외를 활용해 `흐름 제어`를 하고 있다


### 좋은 예시
```java
for(Iterator<Foo> i = collection.iterator(); i.hasNext();){
    Foo foo = i.next(); //상태 검사 메서드 hasNext > 메서드 next
        }
```
- 상태 의존적 메서드 next()를 실행하기 전, 상태 검사 메서드 hasNext()를 통해 검증한다.

### 다른 선택지도 있다 : 옵셔널 / 특정값

- 기준은 무엇일까?
1) 멀티 스레드 환경 > 옵셔널/특정값 :: `TOCTOU - 상태 검사 > 변경 > 상태 의존 메서드 위험`
2) 상태 의존적 메서드와 상태 검사 메서드의 코드 중복 > 옵셔널/특정값
3) 그 이외는 상태 검사 메서드를 사용하자







